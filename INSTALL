Basic Installation
==================


The native build system for libpqxx is based on `configure` and `make`,
but there is also a CMake build.


Native build
------------

This build works on Unix-like systems only (including Linux and macOS).  For
Windows systems, use the CMake build.

The `configure` shell script tries to discover the values for various
system-dependent parameters needed for building libpqxx.  It uses those values
to create a `Makefile` in each directory of your build tree.  It also writes
some header files specific to your build environment.  Finally, it creates a
shell script `config.status` which you can run in the future to recreate the
current configuration, a file `config.cache` that saves the results of its
tests to speed up reconfiguring, and a file `config.log` containing compiler
output (useful mainly for debugging this process).

Two directories matter when building libpqxx: the _source tree_ (where the
libpqxx source code is) and the _build tree_ (where you want your build
artefacts).  Here I will call them `$SRC` and `$BUILD`, but you can call them
anything you like.  They may even be one and the same, but things will be
cleaner and clearer if you keep them separate.

To build, do this in a command-line shell:
 1. Enter `cd $BUILD` to go into the build tree.
 2. `$SRC/configure --help` to read about the options available in the
    `configure` script.
 2. `$SRC/configure' to configure the package for your system.  Add any options
    you need, but it will discover most things for itself.  There should be a
    lot of output as it discovers your compiler, the location of your
    PostgreSQL headers, and so on.
 3. `make' to compile the package.  (To speed this up, add e.g. `-j8` to run up
    to 8 simultanerous compiler processes.)
 4. Optionally, type `make check` to run any self-tests that come with
    the package.
 5. With sufficient privileges to install the package: `make install' to
    perform the actual install.


CMake build
-----------

With CMake you can generate a build setup using your choice of build system.
CMake calls these build systems "generators."  The one I'm most familiar with
is `make` (labeled "Unix Makefiles" in CMake), but there's others such as
`ninja` (labeled "Ninja") which is much faster.  And if you're working with
Visual Studio, you may need to generate project files.

Like the native build, the CMake build needs the libpq library and headers
installed.

If you have the full postgres development package, and you have CMake 3.12 or
better, you can point to the library by setting the `PostgreSQL_ROOT` variable.
For example, if the postgres tree is in `$PGSRC`, then you can set it like:

    cmake -DPostgreSQL_ROOT=$PGSRC

The CMake build works like:
 1. Go into the directory where you would like to build the library and
    its intermediate files.  You can do this in the source directory if you
    like, but the cleaner option is to do it in a separate location.
 2. To generate the build configuration, enter `cmake <sourcedir>`, where
    `<sourcedir>` is the location of the libpqxx source code.  You can also
    specify the type of build you want: `-G Ninja` will make CMake produce a
    Ninja build file, or `-G 'Unix Makefiles'` will make it create Makefiles.
 3. Compile the package.  This depends on what build you chose to generate:
    it might be a matter of running `make`, or of running `ninja`, or something
    else.


Compilers and Options
=====================

   Some systems require unusual options for compilation or linking that
the `configure' script does not know about.  You can give `configure'
initial values for variables by setting them in the environment, or by
adding them to the `configure` command line:

     ./configure CXX='clang++' CXXFLAGS=-O3 LIBS=-lposix


Compiling For Multiple Architectures
====================================

   You can compile the package for more than one kind of computer at the
same time, by placing the object files for each architecture in their
own directory.  To do this, you must use a version of `make' that
supports the `VPATH' variable, such as GNU `make'.  `cd' to the
directory where you want the object files and executables to go and run
the `configure' script.  `configure' automatically checks for the
source code in the directory that `configure' is in and in `..'.

   If you have to use a `make' that does not supports the `VPATH'
variable, you have to compile the package for one architecture at a time
in the source code directory.  After you have installed the package for
one architecture, use `make distclean' before reconfiguring for another
architecture.


Installation Names
==================

   By default, `make install' will install the package's files in
`/usr/local/bin', `/usr/local/man', etc.  You can specify an
installation prefix other than `/usr/local' by giving `configure' the
option `--prefix=PATH'.

   You can specify separate installation prefixes for
architecture-specific files and architecture-independent files.  If you
give `configure' the option `--exec-prefix=PATH', the package will use
PATH as the prefix for installing programs and libraries.
Documentation and other data files will still use the regular prefix.

   In addition, if you use an unusual directory layout you can give
options like `--bindir=PATH' to specify different values for particular
kinds of files.  Run `configure --help' for a list of the directories
you can set and what kinds of files go in them.

   If the package supports it, you can cause programs to be installed
with an extra prefix or suffix on their names by giving `configure' the
option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
